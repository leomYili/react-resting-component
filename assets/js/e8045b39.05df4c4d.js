"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7797],{54153:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"tdd-test","metadata":{"permalink":"/react-stillness-component/blog/tdd-test","editUrl":"https://github.com/leomYili/react-stillness-component/tree/main/docs/blog/\u7528TDD\u7684\u601d\u60f3\u505a\u7ec4\u4ef6\u6d4b\u8bd5.md","source":"@site/blog/\u7528TDD\u7684\u601d\u60f3\u505a\u7ec4\u4ef6\u6d4b\u8bd5.md","title":"Doing Component Testing with TDD Ideas","description":"This is my first blog post about front-end automation testing.","date":"2022-09-24T13:20:00.000Z","formattedDate":"September 24, 2022","tags":[{"label":"TDD","permalink":"/react-stillness-component/blog/tags/tdd"},{"label":"test","permalink":"/react-stillness-component/blog/tags/test"}],"readingTime":6.913333333333333,"truncated":false,"authors":[{"name":"leomYili","title":"creator","url":"https://github.com/leomYili","imageURL":"https://avatars.githubusercontent.com/u/17920032?v=4","key":"leomYili"}],"frontMatter":{"title":"Doing Component Testing with TDD Ideas","description":"This is my first blog post about front-end automation testing.","date":"2022-09-24T13:20","slug":"tdd-test","authors":"leomYili","tags":["TDD","test"],"hide_table_of_contents":false},"nextItem":{"title":"How to implement keep-alive in react","permalink":"/react-stillness-component/blog/realization react-stillness-component"}},"content":"> Test-Driven Development (hereinafter referred to as **TDD**) is a design methodology in which unit test cases are written before the functional code is developed, and tests are used to drive the entire development process.\\n\\nThis article describes in detail how to learn **TDD** in the process of creating the `react-stillness-component` component to complete the functional development and testing. For more details on how the component is implemented, see the previous article \\"How to implement keep-alive in react\\".\\n\\n## I. Preface - automation testing related\\n\\nThis article is written from the point of view of quality and functionality assurance in writing `react` components, which may require some prior knowledge of automation testing due to the terminology involved;\\n\\nThe focus of this article is mainly on how to design and why to use the tdd way to do component testing, any questions, but also welcome to discuss with the author \ud83d\ude01\\n\\n## II. I think the actual implementation process of tdd\\n\\nFirst, a brief review of tdd:\\n\\n![tdd](./assets/10.png)\\n\\nThe actual behavior corresponding to this might be ([from wiki](https://en.wikipedia.org/wiki/Test-driven_development))\\n\\n1. add a test case\\n2. run the test case and get a failed result (because no functionality has been implemented yet)\\n3. write the simplest code that just passes\\n4. re-run the test case and get a successful result\\n5. refactoring as needed, and ensure that each refactoring can pass the previous test cases\\n6. repeat this step, until the completion of the entire development\\n\\nOf course, in the actual development process, the author also made some modifications to the reality of the situation, first look at the process after the transformation:\\n\\n![new flow](./assets/11.png)\\n\\nHere is mainly for the front-end component scenario added some more important steps\\n\\n- Identify the user scenario, under what circumstances to consider using this component? This includes scenarios involving general users and professional users. Need to consider the scenario involving UI framework\\n- Confirm the user behavior, that is, what is the specific operation of the user? You can start from your own perspective, and then conduct actual research to observe how similar components are used\\n- Confirm the user environment, which includes the modern browser environment and the framework itself in the development environment.\\n\\nIn each completed test case before writing the first is to confirm the link to ensure that the function does not deviate from the original intention; after each test, and then verify, and the means of verification can be BDD (will be mentioned later) can also be combined with the reality of online examples to consider, if you can solve the actual problem, then prove that the function has been completed.\\n\\nOf course, as the author\'s own daily habit is to first list the plan \ud83d\ude02, this time is no exception:\\n\\n![mind node1](./assets/12.png)\\n\\nAs you can see the bottom part is the test case planning related to TDD, there will be additional cases in the actual writing process, so the second part is the e2e simulation test is the scope of use of the box, the first phase as long as it does not exceed.\\n\\nThe following look at the actual case\\n\\n## III. Actual cases\\n\\n> The test framework used in this paper is **[jest](https://jestjs.io/)**, the relevant configuration can refer to the first point of the summary of issues\\n\\n### provider\\n\\nFirst of all, starting from the outermost layer, the component makes extensive use of `context`, so it is necessary to provide a global `provider`, because the `value` of `provider` comes from `createStillnessManager()`, so our first example is to determine whether `provider` will work properly when this method is provided\\n\\n```js\\nit(\'Verify that the StillnessManager is correct\', () => {\\n  let capturedManager;\\n  let manager = createStillnessManager(); // let mockManager: any = jest.fn();\\n\\n  render(\\n    <StillnessContext.Provider value={{ stillnessManager: manager }}>\\n      <StillnessContext.Consumer>\\n        {({ stillnessManager }) => {\\n          capturedManager = stillnessManager;\\n          return null;\\n        }}\\n      </StillnessContext.Consumer>\\n    </StillnessContext.Provider>\\n  );\\n\\n  expect(capturedManager).toBe(manager);\\n});\\n```\\n\\nThe difference between the two is that the `mock` approach filters out the interference from the `provider` when writing the code.\\n\\nSo we can now start the `run test`, and of course, since the code is already written, we can get a successful example with either real or mocked arguments.\\n\\nAnd at the beginning, when the code is not written, you can follow the process and write the real code.\\n\\n`provider` will have other functions besides initialization, of course, such as:\\n\\n- automatically clear the global cache object when unloading\\n- prevent multiple provider nesting errors, the need to actively alert the user\\n\\nAnd for these two points, we can continue to write test cases\\n\\n```js\\nit(\'stores StillnessManager in global context and cleans up on unmount\', () => {\\n  let capturedManager;\\n\\n  const { container, unmount } = render(\\n    <StillnessProvider>\\n      <StillnessContext.Consumer>\\n        {({ stillnessManager }) => {\\n          capturedManager = stillnessManager;\\n          return null;\\n        }}\\n      </StillnessContext.Consumer>\\n    </StillnessProvider>\\n  );\\n\\n  const globalInstance = () => (global as any)[INSTANCE_SYM] as any;\\n\\n  expect(globalInstance().stillnessManager).toEqual(capturedManager);\\n  unmount();\\n  expect(globalInstance()).toEqual(null);\\n});\\n```\\n\\nAs you can see, the effect of simulating unloading is achieved by calling the returned method.\\n\\n### class Component\\n\\nLet\'s look at the core of the library, `<OffscreeenComponent>`, the props of the original component are much more complex compared to the component wrapped in `HOC`\\n\\n- uniqueId: UniqueId;\\n- parentId: UniqueId;\\n- parentIsStillness: boolean;\\n- isStillness: boolean;\\n- stillnessManager: StillnessManager;\\n\\nThe test cases also revolve around these points, as an example:\\n\\n```js\\nit(\'Does it prompt an error message when there is no context?\', () => {\\n  global.console.error = jest.fn();\\n\\n  expect(() => {\\n    render(\\n      <OffscreenComponent\\n        visible={true}\\n        isStillness={false}\\n        uniqueId=\\"test1\\"\\n        parentId={rootId}\\n        parentIsStillness={false}\\n      >\\n        <div />\\n      </OffscreenComponent>\\n    );\\n  }).toThrow(/stillnessManager is required/i);\\n});\\n```\\n\\ncomponent is no way to run in the absence of `context`, then we just exclude this parameter when writing the example, if the component catches the exception and throws it, it means that the function is ok, this is a relatively simple example\\n\\nto see a more complex:\\n\\n```js\\nit(\'When the passed isStillness changes, clear the corresponding dom element or reload the original one\', async () => {\\n  const Demo = ({ isStillness }: any) => {\\n    return (\\n      <OffscreenComponent\\n        visible={true}\\n        isStillness={isStillness}\\n        uniqueId=\\"test1\\"\\n        stillnessManager={mockStillnessManager()}\\n        parentId={rootId}\\n        parentIsStillness={false}\\n      >\\n        <div data-testid=\\"content\\" />\\n      </OffscreenComponent>\\n    );\\n  };\\n\\n  const { queryByTestId, rerender } = render(<Demo isStillness={false} />);\\n\\n  rerender(<Demo isStillness={true} />);\\n  expect(queryByTestId(\'content\')).not.toBeInTheDocument();\\n\\n  rerender(<Demo isStillness={false} />);\\n  expect(queryByTestId(\'content\')).toBeInTheDocument();\\n});\\n```\\n\\nThe `isStillness` property of the component is relatively important, but also used to control the conditions of the component is still or not, here through the real simulation of `render`, and by modifying the method of passing the reference, to directly simulate the effect, if passed `true`, the component should be rendered in the `body`, that is, to find the `id` for the `content` element must be able to find, and vice versa, can not find.\\n\\nIn this way, we can test the `class Component`.\\n\\nFor more examples, see [Offscreen.spec.tsx](https://github.com/leomYili/react-stillness-component/blob/main/packages/react-stillness/src/components/__tests__/Offscreen.spec.tsx)\\n\\n### HOC\\n\\nHow is the `HOC` tested? Take the `<Offscreen>` component as an example:\\n\\nIts `props` are:\\n\\n- visible:boolean, controls whether the component is static or not\\n- type: string or number, identifies the type of the component, repeatable, the same type of static behavior will remain the same\\n- scrollRest: boolean type, controls whether the component caches the scroll position when it is stationary\\n\\nBut these `props` are actually processed and passed to the `<OffscreenComponent>` component,\\n\\nFor the `HOC` itself, it just needs to ensure that it catches exceptions when the `context` is not found:\\n\\n```js\\nit(\'throw an error if rendered\', () => {\\n  console.error = jest.fn();\\n\\n  class TestClass extends React.Component<\\n    React.PropsWithChildren<OffscreenInnerProps>\\n  > {}\\n\\n  const DecoratedClass = withNodeBridge(TestClass);\\n\\n  expect(() => {\\n    render(<DecoratedClass visible />);\\n  }).toThrow(/Expected stillness component context/);\\n});\\n```\\n\\nAs for the above `props`, since it involves other modules, it belongs to the scope of `BDD` testing, which will be introduced in the next BDD testing related article\\n\\n### hooks\\n\\nFor `hooks` related, you need to use [@testing-library/react-hooks](https://github.com/testing-library/react-hooks-testing-library) This library can directly run hooks and assert the results\\n\\nAs an example:\\n\\nNow there is a hooks `useOptionalFactory` that returns the latest results based on dependencies\\n\\nThe code is :\\n\\n```js\\nfunction useOptionalFactory<T>(\\n  arg: FactoryOrInstance<T>,\\n  deps?: unknown[]\\n): T {\\n  const memoDeps = [...(deps || [])];\\n  if (deps == null && typeof arg !== \'function\') {\\n    memoDeps.push(arg);\\n  }\\n  return useMemo<T>(() => {\\n    return typeof arg === \'function\' ? (arg as () => T)() : (arg as T);\\n  }, memoDeps);\\n}\\n```\\n\\nThe code for the test case is :\\n\\n```js\\nimport { renderHook, act } from \'@testing-library/react-hooks\';\\n\\nconst useTest = () => {\\n  const [count, setCount] = React.useState(0);\\n\\n  const addCount = () => {\\n    setCount(count + 1);\\n  };\\n\\n  const optionFactoryFn = useOptionalFactory(\\n    () => ({\\n      collect: () => {\\n        return {};\\n      },\\n    }),\\n    [count]\\n  );\\n\\n  return { addCount, optionFactoryFn };\\n};\\n\\ndescribe(\'useOptionalFactory\', () => {\\n  let hook;\\n  it(\'Depending on the variation of the dependency value, different results are generated\', () => {\\n    act(() => {\\n      hook = renderHook(() => useTest());\\n    });\\n\\n    let memoValue = hook.result.current.optionFactoryFn;\\n\\n    act(() => {\\n      hook.result.current.addCount();\\n    });\\n\\n    expect(memoValue).not.toStrictEqual(hook.result.current.optionFactoryFn);\\n  });\\n});\\n```\\n\\nBy using `renderHooks()` and `act()`, you can simply test, and when the test dependencies change, the return value will follow the change.\\n\\n## IV. Summary of questions\\n\\n1. How to set up the test environment?\\n\\n    The overall architecture is `lerna+Typescript+React+rollup+Jest`, in fact, the community also has a lot of examples, here only to introduce the problems encountered in the process of building,\\n\\n    - How to build a separate test environment for sub-packages?\\n      lerna\'s architecture, a good separation of the environment of each package, you can use different test frameworks in each sub-package, individually configured, for example:\\n      ![13](./assets/13.png)\\n      can be configured differently in each package\\n    - Test code also want to use `Typescript`?\\n\\n      ```js\\n      // jest-transformer.js\\n      const babelJest = require(\'babel-jest\');\\n\\n      module.exports = babelJest.createTransformer({\\n        presets: [\\n          [\\n            \'@babel/preset-env\',\\n            {\\n              targets: {\\n                node: \'current\',\\n                esmodules: true,\\n              },\\n              bugfixes: true,\\n              loose: true,\\n            },\\n          ],\\n          \'@babel/preset-typescript\',\\n        ],\\n        plugins: [\\n          [\'@babel/plugin-proposal-class-properties\', { loose: true }],\\n          \'@babel/plugin-transform-react-jsx\',\\n          [\'@babel/plugin-proposal-private-methods\', { loose: true }],\\n          [\\n            \'@babel/plugin-proposal-private-property-in-object\',\\n            { loose: true },\\n          ],\\n          \'@babel/plugin-proposal-object-rest-spread\',\\n          \'@babel/plugin-transform-runtime\',\\n        ],\\n      });\\n\\n      //jest.config.js\\n      module.exports = {\\n        setupFilesAfterEnv: [\'./jest-setup.ts\'],\\n        testMatch: [\\"**/__tests__/**/?(*.)(spec|test).[jt]s?(x)\\"],\\n        // testRegex: \'decorateHandler.spec.tsx\',\\n        transform: {\\n          \\"\\\\\\\\.[jt]sx?$\\": \\"./jest-transformer.js\\",\\n        },\\n        collectCoverageFrom: [\\n          \'**/src/**/*.tsx\',\\n          \'**/src/**/*.ts\',\\n          \'!**/__tests__/**\',\\n          \'!**/dist/**\',\\n        ],\\n        globals: {\\n          __DEV__: true,\\n        },\\n      };\\n      ```\\n\\n      Just add the transform configuration\\n\\n2. How do I test the actual rendering?\\n\\n    You can use [`@testing-library/jest-dom`](https://github.com/testing-library/jest-dom), which provides related `jest` matchers on the `DOM` state, which can be used to check the tree, text, style, etc. of elements, which are also introduced in this article. Some of them, such as:\\n\\n    - toBeInTheDocument: to determine the existence of elements in the document\\n    - toHaveClass: to determine whether the given element in its class attribute has the corresponding class name\\n    - toBeVisible: determine whether the given element is visible to the user\\n\\n3. What if I want to test a particular example individually?\\n\\n    ```js\\n    //jest.config.js\\n    module.exports = {\\n      setupFilesAfterEnv: [\'./jest-setup.ts\'],\\n      //testMatch: [\\"**/__tests__/**/?(*.)(spec|test).[jt]s?(x)\\"],\\n      testRegex: \'decorateHandler.spec.tsx\',\\n      transform: {\\n        \\"\\\\\\\\.[jt]sx?$\\": \\"./jest-transformer.js\\",\\n      },\\n      collectCoverageFrom: [\\n        \'**/src/**/*.tsx\',\\n        \'**/src/**/*.ts\',\\n        \'!**/__tests__/**\',\\n        \'!**/dist/**\',\\n      ],\\n      globals: {\\n        __DEV__: true,\\n      },\\n    };\\n    ```\\n\\n    \u53efYou can simply modify the configuration file, use `testRegex` for a file to test, of course, here the author only listed their own think more simple method, if there is a more simple method, welcome to propose \ud83d\udc4f\ud83d\udc4f\\n\\n4. How to automate testing?\\n\\n    The automated process in the component repository is reflected in the push branch and the automated github release process\\n\\n    ```json\\n    // package.json\\n    \\"scripts\\": {\\n      \\"test\\": \\"jest --projects ./packages/*/\\",\\n      \\"test:coverage\\": \\"jest --coverage --projects ./packages/*/\\",\\n      \\"precommit\\": \\"lint-staged\\",\\n      \\"release\\": \\"bash ./scripts/release.sh\\",\\n      \\"lint:staged\\": \\"lint-staged\\",\\n      \\"ci\\": \\"run-s test:coverage vs git-is-clean\\",\\n    },\\n    \\"lint-staged\\": {\\n      \\"*./packages/**/*.{js,ts,json,css,less,md}\\": [\\n        \\"prettier --write\\",\\n        \\"yarn lint\\"\\n      ],\\n      \\"*./packages/**/__tests__/**/?(*.)(spec|test).[jt]s?(x)\\": [\\n        \\"yarn test\\"\\n      ]\\n    }\\n    ```\\n\\n## V. Summary\\n\\nThis article summarizes how to think and organize the test code in the process of writing a `react` component, of course, in the actual production development stage, there is a certain amount of testing time is the most valuable, but also `TDD` test can be implemented on the basis of, if the `TDD` test to ensure the basic functionality, then `BDD` test is to expand the use of scenarios;\\n\\nAccording to the proportion of the code, the author himself believes that `TDD` accounts for 70%, while `BDD` is the remaining 30%;\\n\\nThis is a cost-effective consideration, after all, in daily work, the requirements are changed very frequently, which means that the component may encounter a variety of different scenarios, and most of the `TDD` test cases can still be retained, but the `BDD` test is not necessarily.\\n\\nThis is the \\"front-end how to do component testing\\" of the first, if there are any questions, welcome to discuss."},{"id":"realization react-stillness-component","metadata":{"permalink":"/react-stillness-component/blog/realization react-stillness-component","editUrl":"https://github.com/leomYili/react-stillness-component/tree/main/docs/blog/react\u4e2d\u5982\u4f55\u5b9e\u73b0keep-alive.md","source":"@site/blog/react\u4e2d\u5982\u4f55\u5b9e\u73b0keep-alive.md","title":"How to implement keep-alive in react","description":"This is my first blog post about front-end automation testing.","date":"2022-08-13T17:00:00.000Z","formattedDate":"August 13, 2022","tags":[{"label":"keep-alive","permalink":"/react-stillness-component/blog/tags/keep-alive"},{"label":"react-stillness-component","permalink":"/react-stillness-component/blog/tags/react-stillness-component"}],"readingTime":8.153333333333334,"truncated":false,"authors":[{"name":"leomYili","title":"creator","url":"https://github.com/leomYili","imageURL":"https://avatars.githubusercontent.com/u/17920032?v=4","key":"leomYili"}],"frontMatter":{"title":"How to implement keep-alive in react","description":"This is my first blog post about front-end automation testing.","date":"2022-08-13T17:00","slug":"realization react-stillness-component","authors":"leomYili","tags":["keep-alive","react-stillness-component"],"hide_table_of_contents":false},"prevItem":{"title":"Doing Component Testing with TDD Ideas","permalink":"/react-stillness-component/blog/tdd-test"},"nextItem":{"title":"\u7528BDD\u7684\u601d\u60f3\u505a\u7ec4\u4ef6\u6d4b\u8bd5","permalink":"/react-stillness-component/blog/bdd-test"}},"content":"> Project-related address: [react-stillness-component](https://leomyili.github.io/react-stillness-component/), the test rate has reached 90%, welcome to try it!\\n>\\n> Official history related discussion: [address](https://github.com/facebook/react/issues/12039)\\n>\\n> Latest react18 official solution discussion: [address](https://github.com/reactwg/react-18/discussions/19)\\n\\nThis article describes in detail how to conceive and implement a component with a global state cache `react-stillness-component`.\\n\\n## I. Preface - Analysis of existing similar components\\n\\nThe normal scenario where authors need to write additional generic components is when they encounter special problems, and existing components are not implemented or would be very costly to develop new components.\\n\\nIn the case of component caching, a good choice for the community would be [React Activation](https://github.com/CJY0208/react-activation/blob/master/README_CN.md), which renders the component in an external hidden component Hierarchy, and then move the component into the corresponding container of the corresponding component through ``DOM`` operations when the component is actually rendered, so that the caching of the component can be controlled by the following syntax:\\n\\n```jsx\\nimport KeepAlive from \'react-activation\'\\n\\n// The components in keepAlive are actually rendered in advance to the external Keeper\\n// Then when keepAlive starts rendering, the corresponding dom nodes are moved here using the data stored in Keeper\\n...\\n\\nfunction App() {\\n  const [show, setShow] = useState(true)\\n\\n  return (\\n    <div>\\n      <button onClick={() => setShow(show => !show)}>Toggle</button>\\n      {show && (\\n        <KeepAlive>\\n          <Counter />\\n        </KeepAlive>\\n      )}\\n    </div>\\n  )\\n}\\n\\n...\\n\\n```\\n\\nIn the react18 before has been considered a relatively good method, but for our scenario there are still several problems:\\n\\n1. the old project code is very large, the implementation of the above method will bring the impact on the dependence on the life cycle order of the function, such as the ref value, although you can setTimeout to delay the acquisition, but one is a slightly large cost, another need to change the previous writing method, the project everywhere in the setTimeout will also affect the reading of the code and code review\\n2. context is actually the same, but compared to the above situation is much better, just need to switch to `react-activation` to provide the createContext that can be\\n3. synthetic event bubbling will fail, which is the fundamental reason for not using the above solution, the author\'s team will have a multi-dimensional table and other complex components, for drag and drop hover positioning will have certain requirements, caching compared to the experience can only be considered an optimization, can not affect the main function.\\n4. In manual caching you need to add `name` to each `<KeepAlive>` component, which also adds some cost.\\n\\nIf it is for new projects, the library can actually reach the production environment level.\\n\\n## II. The ideal effect\\n\\nHere the ideal effect is the author\'s ultimate goal.\\n\\nFirst of all, the effect of `keepalive` can only be considered icing on the cake, it can not affect the development of other features in the project, so similar context, event bubbles, animations and so on can not be affected. 2.\\n2. at the same time, the cost of getting started can not be too high, api to be simple enough, similar to manually increase the unique identity and management of the way the cost is a little high, it is best not to declare the unique identity, but also to manually uninstall.\\n3. performance first, lazy loading, true removal of DOM nodes. 4.\\n4. need to remember the component-level scrolling effect.\\n5. solve the inconsistent caching effect in nested components, if only use a state to control whether to cache, the nested `keep-alive` components will not be able to real-time update.\\n6. unified data communication mechanism and local updates\\n\\nTherefore, in response to the above objectives, the authors finally chose [`Portals\'](https://zh-hans.reactjs.org/docs/portals.html) and redux (to manage the cache state) to solve these problems\\n\\n## III. Implementation principle\\n\\nLet\'s start with a pseudo-code\\n\\n```jsx\\nimport { Offscreen,useStillness } from \'react-stillness-component\';\\n\\n...\\nfunction App() {\\n  const [show, setShow] = useState(true)\\n\\n  return (\\n    <div>\\n      <button onClick={() => setShow(show => !show)}>Toggle</button>\\n      <Offscreen visible={show}>\\n        <Count />\\n      </Offscreen>\\n    </div>\\n  );\\n}\\n\\n...\\nfunction Count() {\\n  const collected = useStillness({\\n    collect: (contract) => ({\\n      stillnessId: contract.getStillnessId(),\\n      unset: contract.unset,\\n      clear: contract.clear,\\n    }),\\n  });\\n\\n  return (\\n    <div>\\n      ....\\n    </div>\\n  );\\n}\\n...\\n```\\n\\nCompared to the current community\'s ability to utilize `didMount`, `unMount`, this is simplified to a prop, with associated hooks to support manual control of the cache.\\n\\nThe core is:\\n\\n```jsx\\n<Offscreen visible={show}>\\n  <Count />\\n</Offscreen>\\n```\\n\\nwill not have a very familiar feeling, if the `Offscreen` replaced by `div`, `visible` replaced by `visibility:visible|hidden`, then it is just a piece of explicit logic to complete the actual effect of the cache \ud83d\ude2c\\n\\nOf course it\'s not that simple, otherwise there would be no need to develop a separate component, but this is really the way the author wanted the component to be used.\\n\\n![example of the principle](./assets/1.png)\\n\\nConvert to code:\\n\\n```jsx\\n...\\n\\ntargetElement = document.createElement(\'div\');\\n\\n// didMount\\ncontainerRef.current.insertAdjacentElement(\\n  \'afterend\',\\n  targetElement\\n);\\n\\nReactDOM.createPortal(props.children, targetElement)\\n\\n...\\n```\\n\\nThen it\'s time for the core extensions, which need to address the consistency of the behavior of the nested `<keepAlive>` related components and the overall cache control.\\n\\n## IV. Functional design\\n\\nFor performance reasons, the redux stores only the data mapping of the cache nodes, and after each cache node is loaded, a corresponding data node will be created synchronously. relationship with other nodes.\\n\\n![context application](./assets/3.png)\\n\\nEach layer just needs to get the id of the nearest `StillnessNodeContext` to build a mapping of nested component relationships,\\n\\nSo the focus of the work is as follows:\\n\\n- Cache node data state design\\n- state synchronization between nodes\\n- Performance optimization, lazy loading\\n\\n### 1. state data structure design\\n\\n![state design](./assets/2.png)\\n\\nHere the vNode is represented as :\\n\\n```js\\ninterface vNodeState {\\n  uniqueId: UniqueId; // \u552f\u4e00\u6807\u8bc6\\n  type?: UniqueId; // \u7c7b\u578b\\n  parentId: UniqueId; // \u7236\u8282\u70b9\u6807\u8bc6\\n  visible?: boolean; // props\u4e2d\u7684\u663e\u9690\u5c5e\u6027\\n  isStillness?: boolean; // \u8ba1\u7b97\u4e4b\u540e\u771f\u5b9e\u7684\u9759\u6b62\u72b6\u6001\\n}\\n```\\n\\noperation may not be easy to understand, but it is mainly used to mark some behavior that may affect the nodes in the global world, such as:\\n\\n- unset: reset the history of the static node\\n- clear: reset the history of all static nodes\\n- mount: A node has triggered a quiescent state\\n- unmount: A node is released from the quiescent state\\n\\nWhen any of the above events is triggered, it is necessary to generate dependencies on the starting node, and sometimes even to update all cache nodes.\\n\\nmax provides a way to control the cache automatically, when the user declares the maximum number of cache nodes, the component will automatically clear or add to the cache according to the rules (the first level `<Offscreen>` node will be counted as a node, and all its children will follow the parent node) and using the `lru` algorithm.\\n\\n### 2. State synchronization\\n\\nSynchronization here means that when a parent node triggers a quiescent operation, it needs to notify all its children in real time. Thanks to the design of the data structure, when a node triggers a quiescent or unquiescent operation, all nodes that need to change their state can be calculated based on `uniqueId` and `parentId`.\\n\\n![state synchronization](./assets/4.png)\\n\\n### 3. Performance optimization\\n\\nPerformance optimizations are mainly in two areas\\n\\n- Local updates: using redux, and the design of the state data structure, each node state update only affects the associated nodes\\n- Lazy loading: In fact, the `visible` attribute on the `<Offscreen>` node can be optimized, if the `visible` attribute is `false` at the beginning, the `children` will not need to be loaded directly\\n\\n```jsx\\nuseIsomorphicLayoutEffect(() => {\\n  if (isMountRef.current) {\\n    const parentIsStillness = globalMonitor.isStillness(stillnessParentId);\\n    uniqueNodeRegistration.update({\\n      ...props,\\n      parentId: stillnessParentId,\\n      isStillness: parentIsStillness || !props.visible,\\n    });\\n\\n    // \u83b7\u53d6\u5230\u771f\u5b9e\u9759\u6b62\u72b6\u6001\\n    const thisIsStillness = globalMonitor.isStillness(\\n      uniqueNodeRegistration.getUniqueId()\\n    );\\n\\n    ...\\n\\n    if (!thisIsStillness) {\\n      setIsCurrentlyMounted(true);\\n    }\\n  }\\n}, [props, stillnessParentId]);\\n\\nuseEffect(() => {\\n  if (isCurrentlyMounted === false) {\\n    if (isMountRef.current) {\\n      setIsCurrentlyMounted(true);\\n    } else {\\n      isMountRef.current = true;\\n    }\\n  }\\n}, [isCurrentlyMounted]);\\n\\nconst RenderedWrappedComponent = useMemo(\\n  () => <Decorated {...wrapperProps} />,\\n  [wrapperProps]\\n);\\n\\nreturn isCurrentlyMounted ? RenderedWrappedComponent : null;\\n```\\n\\nJust note here that it is possible that the parent node is already static, so the child node needs to be lazy loaded even though `visible` is `true`.\\n\\n### 4. Scrolling state memory\\n\\nBecause the node will reset its scrolling position after DOM operation, we need to record the scrolling state of the first level dom node under `<Offscreen>`, and then set the value to restore it when it is lifted from the resting state\\n\\n```jsx\\nlistenerTargetElementChildScroll = () => {\\n  if (this.props?.scrollReset) {\\n    this.targetElement.addEventListener(\\n      \'scroll\',\\n      throttle(\\n        (e: any) => {\\n          if (isRealChildNode(this.targetElement, e.target)) {\\n            let index = this.cacheNodes.findIndex((el) => {\\n              return el.node === e.target;\\n            });\\n\\n            if (index !== -1) {\\n              this.cacheNodes[index] = {\\n                node: e.target,\\n                left: e.target.scrollLeft || 0,\\n                top: e.target.scrollTop || 0,\\n              };\\n            } else {\\n              this.cacheNodes.push({\\n                node: e.target,\\n                left: e.target.scrollLeft || 0,\\n                top: e.target.scrollTop || 0,\\n              });\\n            }\\n          }\\n        },\\n        this,\\n        120\\n      ),\\n      true\\n    );\\n  }\\n};\\n```\\n\\nBecause of the parent-child nested components involved here, the author uses an event listener approach where the scrolling elements under each `<Offscreen>` node are remembered and stored in the scope of that node when a scrolling event is generated under it.\\n\\n### 5. HOC\\n\\nAfter solving the most important problem, the next step is to provide a variety of shortcut usage, the component supports the use of `HOC` and `Hooks`,\\n\\n`HOC` just need to provide a `spec` can:\\n\\n```jsx\\nimport { connectStillness } from \'react-stillness-component\';\\n\\n...\\n\\nconst spec = {\\n  mounted: (props, contract) => {\\n    return \'mounted\';\\n  },\\n  unmounted: (props, contract) => {\\n    return \'unmounted\';\\n  },\\n  collect: (props, contract) => {\\n    return {\\n      isStillness: contract.isStillness(),\\n      stillnessId: contract.getStillnessId(),\\n    };\\n  }\\n};\\n\\nexport const WithCount = connectStillness(spec)(CountComponent);\\n...\\n```\\n\\n`spec` \u53c2\u6570[\u53ef\u4ee5\u53c2\u8003](https://leomyili.github.io/react-stillness-component/zh-CN/docs/api/Decorators/connectStillness)\\n\\n`spec`\u4e2d`collect`\u51fd\u6570\u8fd4\u56de\u7684\u503c\u5c31\u662f\u7ec4\u4ef6\u65b0\u7684`props`;\\n\\n### 6. Hook\\n\\n`Hooks`\u65b9\u9762\u4e3b\u8981\u6709\u4e24\u4e2a`hook`\u6765\u5e2e\u52a9\u7528\u6237\u66f4\u597d\u7684\u5b8c\u6210\u7f13\u5b58\u8282\u70b9\u7684\u63a7\u5236\\n\\n- useStillnessManager:\u504f\u5e95\u5c42\u4e00\u4e9b,\u5c06\u5185\u90e8\u7684\u65b9\u6cd5\u4e5f\u505a\u4e86\u4e00\u5b9a\u7684\u5f52\u7eb3,\u5e76\u63d0\u4f9b\u7ed9\u7528\u6237\u8fdb\u884c\u81ea\u5b9a\u4e49\\n- useStillness:\u4e0e`connectStillness`\u6548\u679c\u4e00\u81f4\\n\\n```jsx\\nimport { useStillness, useStillnessManager } from \'react-stillness-component\';\\n\\nfunction Count(props) {\\n  const stillnessManager = useStillnessManager();\\n  // stillnessManager.getStore();\\n\\n  const [count, setCount] = useState(0);\\n  const collected = useStillness({\\n    mounted: (contract) => {\\n      return \'mounted\';\\n    },\\n    unmounted: (contract) => {\\n      return \'unmounted\';\\n    },\\n    collect: (contract) => {\\n      return {\\n        isStillness: contract.isStillness(),\\n        stillnessId: contract.getStillnessId(),\\n        item: contract.getStillnessItem(),\\n      };\\n    },\\n  });\\n\\n  useEffect(() => {\\n    console.log(collected);\\n  }, [collected]);\\n\\n  return <div>...</div>;\\n}\\n```\\n\\nThe above is the overall architecture design. If you are interested, you can take a look at the source code, the structure is based on the idea of `react-dnd`, and you can also re-read how it is designed to separate the data state from the UI.\\n\\nAfter that, we will show you the practical application of `react-stillness-component`.\\n\\n## V. Practical Exercises\\n\\nThe following examples are only written by the author according to his own situation, in fact, the component itself is very simple, there is no obvious compatibility issues, if there is a combination of other libraries can not achieve the effect, you are welcome to contact the author.\\n\\n### 1. first is a simple demo\\n\\n![simple example](./assets/5.gif)\\n\\nYou can see the exact effect through [online demo](https://codesandbox.io/s/02-example-react-379q3k?from-embed).\\n\\n### 2. Then comes the most common `react-router`, which is divided into v5 and v6 versions\\n\\n![react-router v5](./assets/6.gif)\\n\\nThe main thing in `react-router-v5` is the customization of the `<Switch>` component, which achieves the effect of route caching, for more details, [you can refer to](https://leomyili.github.io/react-stillness-component/zh-CN/ docs/examples/react-router/v5), and debug it yourself\\n\\n![react-router v6](./assets/7.gif)\\n\\n`react-router-v6` version is much simpler, just need to customize the outlet, you can achieve the effect of caching, the source code [can refer to](https://codesandbox.io/s/04-example-react-routerv6-uuv2xc?from-embed), and debug yourself\\n\\n### 3. then is the application in the `umi v3` framework, which is also the author\'s current team\'s basic framework\\n\\nFirst you need to install the wrapped plugin `yarn add umi-plugin-stillness react-stillness-component`;\\n\\nNext, use it in `.umirc.ts`:\\n\\n```js\\nimport { defineConfig } from \'umi\';\\n\\nexport default defineConfig({\\n  nodeModulesTransform: {\\n    type: \'none\',\\n  },\\n  routes: [\\n    {\\n      exact: false,\\n      path: \'/\',\\n      component: \'@/layouts/index\',\\n      routes: [\\n        {\\n          exact: false,\\n          path: \'/home\',\\n          component: \'@/pages/home\',\\n          stillness: true,\\n          routes: [\\n            {\\n              path: \'/home/a\',\\n              component: \'@/pages/a\',\\n              stillness: true,\\n            },\\n          ],\\n        },\\n        { path: \'/about\', component: \'@/pages/about\', stillness: true },\\n        { path: \'/list\', component: \'@/pages/list\' },\\n      ],\\n    },\\n  ],\\n  stillness: {},\\n});\\n```\\n\\nAdd `stillness:true` to the nodes that need to be cached\\n\\nEffect:\\n\\n![umi demo](./assets/8.gif)\\n\\nThe most important thing is to customize the `<Switch>` component, use the `modifyRendererPath` capability, redefine the new `renderer`, and then use the `react-route-v5` similar modification method, you can achieve the effect. The downside is that it needs to be synchronized and updated in time, for example, the new `react18` related capabilities, the author has not yet updated up.\\n\\n[Online address](https://codesandbox.io/s/05-example-umi-v3-plugin-puubqt?from-embed=&file=/src/pages/list.tsx), you can debug it yourself\\n\\n### 4. and the author\'s own more interested in `next.js` framework\\n\\nnextjs is relatively special, the file routing system can not be modified externally, therefore, customize the _app.js, by adding StillnessSwitch component, simply turn the routing components under it into stationary components.\\n\\n```jsx\\nimport React, { useState, useEffect } from \'react\';\\nimport { useRouter } from \'next/router\';\\nimport { Offscreen } from \'react-stillness-component\';\\n\\nfunction matchPath(pathname, routes) {\\n  const result = routes.find(({ path }) => path === pathname) || null;\\n\\n  return result;\\n}\\n\\nconst StillnessSwitch = (props) => {\\n  const { Component, pageProps } = props;\\n  const router = useRouter();\\n  const [stillnessRoutes, setStillnessRoutes] = useState([]);\\n  const [route, setRoute] = useState([]);\\n\\n  useEffect(() => {\\n    if (pageProps.stillness) {\\n      !matchPath(router.pathname, stillnessRoutes) &&\\n        setStillnessRoutes([\\n          ...stillnessRoutes,\\n          { Page: Component, _props: pageProps, path: router.pathname },\\n        ]);\\n      setRoute([]);\\n    } else {\\n      setRoute([\\n        {\\n          Page: Component,\\n          _props: pageProps,\\n          path: router.pathname,\\n        },\\n      ]);\\n    }\\n  }, [Component, router.pathname]);\\n\\n  return (\\n    <>\\n      {stillnessRoutes.concat(route).map(({ Page, _props, path }) => {\\n        if (_props.stillness) {\\n          return (\\n            <Offscreen\\n              key={path}\\n              type={path}\\n              visible={path === router.pathname}\\n            >\\n              <Page {..._props} />\\n            </Offscreen>\\n          );\\n        }\\n\\n        return <Page {..._props} />;\\n      })}\\n    </>\\n  );\\n};\\n\\nexport default StillnessSwitch;\\n```\\n\\n![nextjs demo](./assets/9.gif)\\n\\n[online address](https://codesandbox.io/s/06-example-nextjs-kwcu20?from-embed=&file=/pages/index.js), you can debug it yourself\\n\\n## Summary\\n\\nThis article describes in detail how to achieve the effect of `keep-alive` in react, and describes in detail the specific ideas, the author actually wanted to introduce the automation testing of components, but later in the actual scenario encountered this demand, then simply the first component to achieve, and then use the actual components to complete the front-end testing. This is \\"front-end how to do component testing\\" of the opening, if there are any questions, welcome to discuss together."},{"id":"bdd-test","metadata":{"permalink":"/react-stillness-component/blog/bdd-test","editUrl":"https://github.com/leomYili/react-stillness-component/tree/main/docs/blog/BDD Test.md","source":"@site/blog/BDD Test.md","title":"\u7528BDD\u7684\u601d\u60f3\u505a\u7ec4\u4ef6\u6d4b\u8bd5","description":"\u8fd9\u662f\u6211\u5173\u4e8e\u524d\u7aef\u81ea\u52a8\u5316\u6d4b\u8bd5\u7684\u7b2c\u4e8c\u7bc7\u535a\u6587\u3002","date":"2022-07-31T13:30:00.000Z","formattedDate":"July 31, 2022","tags":[{"label":"BDD","permalink":"/react-stillness-component/blog/tags/bdd"},{"label":"test","permalink":"/react-stillness-component/blog/tags/test"}],"readingTime":0,"truncated":false,"authors":[{"name":"leomYili","title":"creator","url":"https://github.com/leomYili","imageURL":"https://avatars.githubusercontent.com/u/17920032?v=4","key":"leomYili"}],"frontMatter":{"title":"\u7528BDD\u7684\u601d\u60f3\u505a\u7ec4\u4ef6\u6d4b\u8bd5","description":"\u8fd9\u662f\u6211\u5173\u4e8e\u524d\u7aef\u81ea\u52a8\u5316\u6d4b\u8bd5\u7684\u7b2c\u4e8c\u7bc7\u535a\u6587\u3002","date":"2022-07-31T13:30","slug":"bdd-test","authors":"leomYili","tags":["BDD","test"],"hide_table_of_contents":false},"prevItem":{"title":"How to implement keep-alive in react","permalink":"/react-stillness-component/blog/realization react-stillness-component"}},"content":""}]}')}}]);